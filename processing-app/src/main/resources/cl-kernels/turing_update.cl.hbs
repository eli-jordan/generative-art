
/*
 * This file is a template that is used to generate the OpenCL kernel that performs
 * a multi-scale turing pattern update, when given as input the pre-calculated
 * activator and inhibitor buffers.
 *
 * Code generation is used because OpenCL doesn't support passing a variable number
 * of images as arguments. So, we code-gen the variable number of arguments.
 */

inline float map(float value,
    float start1, float stop1,
    float start2, float stop2) {
    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
}

kernel void turing_update(
    {{#each indices}}read_only image2d_t activator{{this}},
    {{/each}}
    {{#each indices}}read_only image2d_t inhibitor{{this}},
    {{/each}}
    {{#each indices}}float small_amount{{this}},
    {{/each}}
    read_only image2d_t grid_in,
    write_only image2d_t grid_out,
    float max_inc
) {
    int2 coord = (int2)(get_global_id(0), get_global_id(1));

    // Lookup the activator value for each input
    {{#each indices}}float activator{{this}}_value = read_imagef(activator{{this}}, coord).x;
    {{/each}}

    // Lookup the inhibitor value for each input
    {{#each indices}}float inhibitor{{this}}_value = read_imagef(inhibitor{{this}}, coord).x;
    {{/each}}

    // Calculate the variation value for each activator/inhibitor combination
    {{#each indices}}float variation{{this}} = fabs(activator{{this}}_value - inhibitor{{this}}_value);
    {{/each}}

    // Calculate whether the increment will be positive or negative for a given input
    {{#each indices}}float multiplier{{this}} = activator{{this}}_value > inhibitor{{this}}_value ? 1.0 : -1.0;
    {{/each}}

    float min_variation = variation0;
    float small_amount = small_amount0;
    float multiplier = multiplier0;

    // Calculate the attributes for the "winning" scale i.e. the one with the smallest variation.
    {{#each indices}}
        if(variation{{this}} < min_variation) {
            min_variation = variation{{this}};
            small_amount = small_amount{{this}};
            multiplier = multiplier{{this}};
        }
    {{/each}}

    float new_value = read_imagef(grid_in, coord).x + small_amount * multiplier;

    // We want to normalise the values into the range [-1,1]. To do this 100% correctly
    // we would need to perform another reduction on the grid data to find the minimum and maximum
    // then scale the data using those.
    //
    // To avoid the min/max computation, we observe that at each step the maximum delta
    // of any given value will be the maximum `small_amount` variable.
    // So we use normalise to the range [-1 - max(small_amounts), 1 + max(small_amounts)]
    new_value = map(new_value, -1 - max_inc, 1 + max_inc, -1, 1);

    write_imagef(grid_out, coord, (float4)(new_value, 0.0, 0.0, 0.0));
}
